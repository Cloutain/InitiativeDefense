//-------------------MEMmon控制-------------------
#define IOCTL_GET_MEMINFO CTL_CODE(FILE_DEVICE_UNKNOWN,0x0830, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SET_APPEVENT_OK CTL_CODE(FILE_DEVICE_UNKNOWN,0x0831, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SET_APPEVENT_NO CTL_CODE(FILE_DEVICE_UNKNOWN,0x0832, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TURNON_MEMMON CTL_CODE(FILE_DEVICE_UNKNOWN,0x0833, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TURNOFF_MEMMON CTL_CODE(FILE_DEVICE_UNKNOWN,0x0834, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


int TurnOnMemMon=1;//默认开启
int MemPass=1;//默认通过
//-------------------MEMmon控制结束-------------------

typedef struct _MemCallbackInfo
{
	CHAR    ProcName[256];	//进程名
	CHAR    ProcFullPath[256];          //进程路径
	CHAR    Info1[256];					//信息1
	CHAR    Info2[256];					//信息2
 } MEM_CALLBACK_INFO, *MEM_PCALLBACK_INFO;
